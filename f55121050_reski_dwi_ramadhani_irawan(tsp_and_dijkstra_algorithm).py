# -*- coding: utf-8 -*-
"""F55121050_Reski Dwi Ramadhani Irawan(TSP and Dijkstra Algorithm).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G9WOz-MEdeP00JQOcFhQ5K4XLeKJbsrF
"""

import time
import sys
from itertools import permutations
from collections import deque

# Fungsi untuk menghitung jarak antara dua titik
def hitung_jarak(titik1, titik2):
    return graph[titik1][titik2]

# Algoritma TSP
def tsp():
    start_node = input("Masukkan titik awal: ")
    end_node = input("Masukkan titik tujuan: ")

    start_time = time.time()
    shortest_jarak = sys.maxsize
    shortest_rute = []

    # Generate semua kemungkinan rute
    if len(graph) <= 10:
        all_rute = permutations(graph.keys())
    else:
        all_rute = [list(graph.keys())]

    for rute in all_rute:
        total_jarak = sum(hitung_jarak(rute[i], rute[i+1]) for i in range(len(rute) - 1))
        if total_jarak < shortest_jarak:
            shortest_jarak = total_jarak
            shortest_rute = rute

        # Menampilkan setiap iterasi
        print(f"Iterasi: {rute} - Jarak: {total_jarak}")

    end_time = time.time()
    execution_time = end_time - start_time

    # Menampilkan waktu komputasi
    print("\nWaktu Komputasi:", execution_time, "detik")

    # Menampilkan hasil akhir
    print("\nShortest Path:")
    print(shortest_rute)
    print("Jarak:", shortest_jarak)

# Algoritma Dijkstra
def dijkstra():
    start_node = input("Masukkan titik awal: ")
    end_node = input("Masukkan titik tujuan: ")

    start_time = time.time()

    # Inisialisasi jarak awal dan rute
    jarak = {node: sys.maxsize for node in graph}
    jarak[start_node] = 0
    rute = {start_node: []}

    # Simpan node yang belum dikunjungi
    unvisited = set(graph.keys())

    while unvisited:
        # Pilih node dengan jarak terkecil
        current_node = min(unvisited, key=lambda node: jarak[node])

        # Hentikan jika mencapai titik tujuan
        if current_node == end_node:
            break

        unvisited.remove(current_node)

        # Update jarak terpendek untuk tetangga yang belum dikunjungi
        for neighbor in graph[current_node]:
            if neighbor in unvisited:
                new_distance = jarak[current_node] + graph[current_node][neighbor]
                if new_distance < jarak[neighbor]:
                    jarak[neighbor] = new_distance
                    rute[neighbor] = rute[current_node] + [current_node]

        # Menampilkan setiap iterasi
        print(f"Iterasi: Rute {rute[current_node] + [current_node]} - Jarak: {jarak[current_node]}")

    # Membangun rute terpendek
    shortest_rute = deque(rute[end_node] + [end_node])

    end_time = time.time()
    execution_time = end_time - start_time

    # Menampilkan waktu komputasi
    print("\nWaktu Komputasi:", execution_time, "detik")

    # Menampilkan hasil akhir
    print("\nShortest Path:")
    print(list(shortest_rute))
    print("Jarak:", jarak[end_node])

# Graph yang merepresentasikan jarak antara titik-titik
graph = {
    'A': {'B': 12, 'C': 10, 'D': float('inf'), 'E': float('inf'), 'F': float('inf'), 'G': 12},
    'B': {'A': 12, 'C': 8,  'D': 12, 'E': float('inf'), 'F': float('inf'), 'G': float('inf')},
    'C': {'A': 10, 'B': 8,  'D': 11, 'E': 3, 'F': float('inf'), 'G': 9},
    'D': {'A': float('inf'), 'B': 12, 'C': 11, 'E': 11, 'F': 10, 'G': float('inf')},
    'E': {'A': float('inf'), 'B': float('inf'), 'C': 3, 'D': 11, 'F': 6, 'G': 7},
    'F': {'A': float('inf'), 'B': float('inf'), 'C': float('inf'), 'D': 10, 'E': 6, 'G': 9},
    'G': {'A': 12, 'B': float('inf'), 'C': 9, 'D': float('inf'), 'E': 7, 'F': 9},
}


# Main program
print("=== Program Menghitung Shortest Path ===")
print("Pilihan:")
print("1. TSP (Traveling Salesman Problem)")
print("2. Dijkstra")
choice = input("Masukkan pilihan (1/2): ")

if choice == '1':
    print("\nAlgoritma TSP")
    tsp()
elif choice == '2':
    print("\nAlgoritma Dijkstra")
    dijkstra()
else:
    print("Pilihan tidak valid.")